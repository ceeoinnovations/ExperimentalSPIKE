<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Get my IP with GPT</title>
</head>

<body>
  <h1>What is my (public) IP address?</h1>
  <h3>My IP Address: </h3>
  <button onclick="getmyip()">Get My IP</button>

  <script>
    function getmyip() {
      fetch("https://api.ipify.org/?format=json").then(res => res.json()).then(res => console.log(res))
    }

    function getmyipGPT() {
      const messagesJSONList = [
        { "role": "system", "content": `



from hub import light_matrix
import runloop

async def main():
    # write your code here
    await light_matrix.write("Hi!")

runloop.run(main())





Challenge
Can you change the code to run the motor at 1000 degrees per second when the Force Sensor is fully pressed?

Sensor Conditions
You’ve used the sensor value to control a motor directly, but it’s also possible to change the flow of the program using sensor conditions and an ifstatement. The if statement is an essential part of programming and the simplest way to control the flow of your program.
You create an if statement by writing if followed by a logical expression and a colon. Logical expressions are basically yes / no questions, such as “Is the color red?” or “Is the button pressed?” If the answer to the question is “yes,” the expression is evaluated to be True and otherwise it is False. These are the two Boolean values used in Python, and are of type bool. All the lines of code with the same indentation level after the if statement are part of the code block that runs if the expression is True.
For an example, connect a Color Sensor to port A and run the program below.


from hub import port, speaker
import color
import color_sensor
import runloop

async def main():
    while True:
        # Check if the red color is detected.
        if color_sensor.color(port.A) == color.RED:
            # If red is detected start a very long beep.
            speaker.beep(440, 1000000, 100)
            # Pause the program while red is detected.
            while color_sensor.color(port.A) == color.RED:
                await runloop.sleep_ms(1)
            # Stop the sound when red is no longer detected.
            speaker.stop()

runloop.run(main())
Wave a red LEGO® brick in front of the Color Sensor while the program is running. You’ll hear a beep when the red color is detected, which stops when the red color is no longer detected. The example uses an if statement to check if the color detected by the Color Sensor is red. It does this using the equality operator == with the Color Sensor color value on the left and the color.RED constant on the right. (Note that there are two = signs vs. the single = sign you used to assign values to variables.) If the Color Sensor color value is the same as the color.RED constant, the condition is True and the code block after the if statement runs.
It’s important to wrap the code in a while True loop. Otherwise, the Color Sensor only checks the color for a split second when the program starts. So far, you used the while loop with the True constant to repeat code forever. You can also use the while loop with a logical expression to repeat code only as long as that expression evaluates to True. The example above uses the same condition as the if statement in the inner while loop, to continue playing the beep while the red color is detected. When the condition is no longer True, the Hub exits the while loop and runs the next line of code to stop the sound.
Inside the inner while loop, notice the sleep_ms() function from the runloop module. This function pauses the main() coroutine for a number of milliseconds in a non-blocking way. Because it uses the await keyword, other tasks can run while that coroutine is paused. In the example, the pause is one millisecond. This may seem like very little time, but it’s enough for the Hub to run many coroutines concurrently. The sleep_ms() function from the time module, which you used in earlier chapters, pauses the program in a blocking way. This means that it pauses the entire program and not just the code block where you call it.

What Else?
You can add more than one condition by extending the if statement with an elif statement that checks another condition. You can add as many of these as you need, and they follow the same syntax as the if statement. The elif should be on the same indentation level as the first if statement, and the elif keyword is followed by a logical expression and a colon. Indent the next line(s) of code that should run when this condition is True.
Sometimes, none of the conditions in the if and elif statements are True. In this case, you can run some code by adding an else statement without any condition. This runs when all the previous conditions are False.
For example, the program below adds an elif and else statement to also beep if the left button is pressed.

from hub import button, port, speaker
import color
import color_sensor
import runloop

# This function returns True if the Color Sensor detects red.
def red_detected():
    return color_sensor.color(port.A) == color.RED

# This function returns True if the left button is pressed.
def left_pressed():
    return button.pressed(button.LEFT) > 0

async def main():
    while True:
        if red_detected():
            # If red is detected start a very long beep.
            speaker.beep(440, 1000000, 100)
            # Wait until red is no longer detected.
            while red_detected():
                await runloop.sleep_ms(1)
        elif left_pressed():
            # If the left button is pressed make a short beep.
            speaker.beep(880, 200, 100)
            # Wait until the left button is released.
            while left_pressed():
                await runloop.sleep_ms(1)
        else:
            # Otherwise, stop the sound.
            speaker.stop()

runloop.run(main())
Wave a red LEGO brick in front of the Color Sensor and press the left button on the Hub while the program is running. You’ll hear a beep for as long as the red color is detected, and a short beep each time the left button is pressed.
The example defines two functions to do the logic tests and return the result. The red_detected() function checks if the color detected by the Color Sensor is red and returns the result True or False. The left_pressed() function uses the pressed() function from the hub.button module and uses the > operator to check if the value is greater than 0 and returns the result.
The code in the if statement here is largely the same as the first example, but now it uses the red_detected() function in two places instead of repeating the condition for the if and while statements. The elif statement uses the left_pressed() function to check if the left button on the Hub is pressed for more than 0 milliseconds.
Note that the elif statement only runs when the condition of the first if statement is False. Therefore, pressing the button while the Color Sensor detects something red has no effect. You should carefully consider the order of your if and elif conditions and check the most important ones first. The else statement stops the sound if neither condition is True.

Multiple Conditions
When you use if/elif/else statements to test for multiple conditions, only one of the blocks will run. These conditions are mutually exclusive. You’ve seen that while the color red was detected, pressing the left button had no effect. To truly check multiple conditions, you must check them at the same time. Like adding several stacks of Word Blocks, in Python you can run multiple coroutines with the run() function from the runloop module. Until now, you’ve called it with the main() coroutine as its only argument, but it’s possible to pass multiple coroutines as comma-separated arguments.
For example, the program below divides the code that checks the detected color and the pressed button into two coroutines. The run() function on the final line of code starts both coroutines at the same time.

from hub import button, port, speaker
import color
import color_sensor
import runloop

# This function returns  if the Color Sensor detects red.
def red_detected():
    return color_sensor.color(port.A) == color.RED

# This function returns  if the left button is pressed.
def left_pressed():
    return button.pressed(button.LEFT) > 0

# This coroutine continuously checks if the Color Sensor detects red.
async def check_color():
    while True:
        # Wait until red is detected.
        while not red_detected():
            await runloop.sleep_ms(1)
        # When it's detected start a very long beep.
        speaker.beep(440, 1000000, 100)
        # Wait until red is no longer detected.
        while red_detected():
            await runloop.sleep_ms(1)
        # When red is no longer detected stop the sound.
        speaker.stop()

# This coroutine continuously checks if the left button is pressed.
async def check_button():
    while True:
        # Wait until the left button is pressed.
        while not left_pressed():
            await runloop.sleep_ms(1)
        # When it's pressed make a short beep.
        speaker.beep(880, 200, 100)
        # Wait until the left button is released.
        while left_pressed():
            await runloop.sleep_ms(1)

# Run both coroutines.
runloop.run(check_color(), check_button())
Wave a red LEGO brick in front of the Color Sensor and press the left button on the Hub while the program is running. Like before, you’ll hear a beep for as long as the red color is detected, and a short beep each time the left button is pressed. This time, it’s possible to press the left button and hear a beep while the red color is detected because both functions run at the same time.
When you create your own coroutines, remember that:
	•	Your coroutines should at least await one command.
	•	When you use a tight while loop, use await runloop.sleep_ms(1) inside the loop to give other coroutines a chance to start and run.

Challenge
Can you change the code to detect a different color than red?

Next Steps
In the previous chapters, you
	•	learned the basics of using Python with SPIKE Prime, and how to use the Hub Light Matrix, Light, Speaker, and Buttons, as well as the motors, Color Sensor, and Force Sensor.
	•	became familiar with regular and asynchronous functions, local and global variables, and data types such as int, bool, str, tuple, and list.
	•	used for and while loops, as well as if/elif/else statements to control the flow of your program.
	•	learned how to use comments in your code, and when things go wrong, how to debug the program.
This is quite an achievement – you can be proud of yourself!
There are additional resources you can access to learn even more about using Python with SPIKE Prime.

Python User Guide
This Getting Started section has barely scratched the surface of what’s possible with Python and SPIKE Prime. Explore these three other sections of the Python User Guide.
	1.	Examples Find example programs that show how to use Python to solve various tasks. Copy and try them, then modify them to suit your needs.
	2.	SPIKE Prime Modules Find documentation of all the functions and variables in the SPIKE Prime modules with short examples of how to use them.
	3.	Word Block Translator See what each Word Block translates to in Python code. This is handy if you want to translate a Word Block program to Python code.

Python Lessons
On the LEGOeducation.com/lessons website, select the product SPIKE™ Prime with Python. You’ll find several unit plans with 6–8 lessons each (available in English only). These 50+ lessons cover a wide range of topics, from debugging to sensor control, and from simple games to data and math functions. Discover the many possibilities and become an expert using Python with SPIKE Prime.

Challenge
Create a new Python project and get coding!

API Modules

Color
The color module contains all the color constants and some convenience functions to use with the color_matrix, color_sensor and light modules.
To access this module you need to:
To use the Color module add the following import statement to your project:

import color
All functions in the module should be called inside the color module as a prefix like so:

color.rgb(color.BLUE)

Functions

rgb
rgb(color: int) -> tuple[int, int, int]
Convert any built in color to its rgb value.

from hub import port
import color

# Print the rgb value of red 
print(color.rgb(color.RED))

Parameters


color: int
A color from the color module

Constants


color Constants
BLACK = 0
MAGENTA = 1
PURPLE = 2
BLUE = 3
AZURE = 4
TURQUOISE = 5
GREEN = 6
YELLOW = 7
ORANGE = 8
RED = 9
WHITE = 10
UNKNOWN = -1

Color Matrix
To use the Color Matrix module add the following import statement to your project:

import color_matrix
All functions in the module should be called inside the color_matrix module as a prefix like so:

color_matrix.set_pixel(port.A, 1, 1, color.BLUE, 10)

Functions

clear
clear(port: int) -> None
Turn off all pixels on a Color Matrix

from hub import port
import color
import color_matrix

color_matrix.clear(port.A)

Parameters


port: int
A port from the port submodule in the hub module

get_pixel
get_pixel(port: int, x: int, y: int) -> int
Retrieve the color shown in a specific pixel

from hub import port
import color_matrix

# Print the color of the 0,0 pixel on the Color Matrix connected to port A 
print(color_matrix.get_pixel(port.A, 0, 0))

Parameters


port: int
A port from the port submodule in the hub module

x: int
The X value

y: int
The Y value

set_pixel
set_pixel(port: int, x: int, y: int, color: int, intensity: int) -> None
Change a single pixel on a Color Matrix

from hub import port
import color
import color_matrix

# Change the color of the 0,0 pixel on the Color Matrix connected to port A 
color_matrix.set_pixel(port.A, 0, 0, color.RED, 10)

# Print the color of the 0,0 pixel on the Color Matrix connected to port A 
print(color_matrix.get_pixel(port.A, 0, 0))

Parameters


port: int
A port from the port submodule in the hub module

x: int
The X value

y: int
The Y value

color: int
A color from the color module

intensity: int
How bright to light up the pixel

show
show(port: int, pixels: bytes) -> None
Change all pixels at once on a Color Matrix

from hub import port
import color
import color_matrix

# Update all pixels on Color Matrix using the show function 

# Create a list with 18 items (color and intensity pairs) 
pixels = [color.BLUE, 10] * 9 

# Wrap pixels list inside a bytes object 
pixels_bytes = bytes(pixels)

# Update all pixels to show same color and intensity 
color_matrix.show(port.A, pixels_bytes)

Parameters


port: int
A port from the port submodule in the hub module

pixels: bytes
A bytes object containing color and intensity values for all 9 pixels.

Color Sensor
The color_sensor module enables you to write code that reacts to specific colors or the intensity of the reflected light.
To use the Color Sensor module add the following import statement to your project:

import color_sensor
All functions in the module should be called inside the color_sensor module as a prefix like so:

color_sensor.reflection(port.A)

Functions

can_detect
can_detect(port: int, color: int) -> bool
Tests if a color is detectable by the color sensor attached to port.

Parameters


port: int
A port from the port submodule in the hub module

color: int
A color from the color module

color
color(port: int) -> int
Returns the color value of the detected color. Use the color module to map the color value to a specific color.

import color_sensor
from hub import port
import color

if color_sensor.color(port.A) is color.RED:
    print("Red detected")

Parameters


port: int
A port from the port submodule in the hub module

raw_rgbi
raw_rgbi(port: int) -> tuple[int, int, int, int]
Retrieves the overall colour intensity and intensity of red, green and blue.
Returns tuple[red: int, green: int, blue: int, intensity: int]

Parameters


port: int
A port from the port submodule in the hub module

reflection
reflection(port: int) -> int
Retrieves the intensity of the reflected light (0-100%).

Parameters


port: int
A port from the port submodule in the hub module

Device
The device module enables you to write code to get information about devices plugged into the hub.
To use the Device module add the following import statement to your project:

import device
All functions in the module should be called inside the device module as a prefix like so:

device.device_id(port.A)

Functions

data
data(port: int) -> tuple[int]
Retrieve the raw LPF-2 data from a device.

Parameters


port: int
A port from the port submodule in the hub module

device_id
device_id(port: int) -> int
Retrieve the device id of a device. Each device has an id based on its type.

Parameters


port: int
A port from the port submodule in the hub module

get_duty_cycle
get_duty_cycle(port: int) -> int
Retrieve the duty cycle for a device.

Parameters


port: int
A port from the port submodule in the hub module

is_ready
is_ready(port: int) -> bool
When a device is attached to the hub it might take a short amount of time before it's ready to accept requests.Use is_ready to test for the readiness of the attached devices if you've replaced main.py on the hub with your own program

Parameters


port: int
A port from the port submodule in the hub module

set_duty_cycle
set_duty_cycle(port: int, duty_cycle: int) -> None
Set the duty cycle on a device.

Parameters


port: int
A port from the port submodule in the hub module

duty_cycle: int
The PWM value in percentage (0-100)

Constants


device Constants
COLOR_SENSOR = 61
FORCE_SENSOR = 63

Distance Sensor
The distance_sensor module enables you to write code that reacts to specific colors or the intencity of the reflected light.
To use the Distance Sensor module add the following import statement to your project:

import distance_sensor
All functions in the module should be called inside the distance_sensor module as a prefix like so:

distance_sensor.distance(port.A)

Functions

clear
clear(port: int) -> None
Turns off all the lights in the Distance Sensor connected to port.

Parameters


port: int
A port from the port submodule in the hub module

distance
distance(port: int) -> int
Retrieve the distance in millimeters captured by the Distance Sensor connected to port. If the Distance Sensor cannot read a valid distance it will return -1.

Parameters


port: int
A port from the port submodule in the hub module

get_pixel
get_pixel(port: int, x: int, y: int) -> int
Retrieve the intensity of a specific light on the Distance Sensor connected to port.

Parameters


port: int
A port from the port submodule in the hub module

x: int
The X value

y: int
The Y value

set_pixel
set_pixel(port: int, x: int, y: int, intensity: int) -> None
Changes the intensity of a specific light on the Distance Sensor connected to port.

Parameters


port: int
A port from the port submodule in the hub module

x: int
The X value

y: int
The Y value

intensity: int
How bright to light up the pixel

show
show(port: int, pixels: bytes) -> None
Change all the lights at the same time.

from hub import port
import distance_sensor

# Update all pixels on Distance Sensor using the show function 

# Create a list with 4 identical intensity values 
pixels = [100] * 4 

# Wrap pixels list inside a bytes object 
pixels_bytes = bytes(pixels)

# Update all pixels to show same intensity 
distance_sensor.show(port.A, pixels_bytes)

Parameters


port: int
A port from the port submodule in the hub module

pixels: bytes
A bytes object containing intensity values for all 4 pixels.

Force Sensor
The force_sensor module contains all functions and constants to use the Force Sensor.
To use the Force Sensor module add the following import statement to your project:

import force_sensor
All functions in the module should be called inside the force_sensor module as a prefix like so:

force_sensor.force(port.A)

Functions

force
force(port: int) -> int
Retrieves the measured force as a percentage of the maximum force.

from hub import port
import force_sensor


print(force_sensor.force(port.A))

Parameters


port: int
A port from the port submodule in the hub module

is_pressed
is_pressed(port: int) -> bool
Tests whether the button on the sensor is pressed. Returns true if the force sensor connected to port is pressed.

from hub import port
import force_sensor


print(force_sensor.is_pressed(port.A))

Parameters


port: int
A port from the port submodule in the hub module

raw
raw(port: int) -> int
Returns the raw force value of the force sensor connected on port port

from hub import port
import force_sensor


print(force_sensor.raw(port.A))

Parameters


port: int
A port from the port submodule in the hub module

Hub
The hub module enables you to write code that acts on the hub itself.

Sub Modules

Button
To use the Button module add the following import statement to your project:

from hub import button
All functions in the module should be called inside the hub module as a prefix like so:

button.pressed(button.LEFT)

Functions

pressed
int pressed(button: int) -> int
This module allows you to react to buttons being pressed on the hub. You must first import the button module to use the buttons.

from hub import button

left_button_press_duration = 0

# Wait for the left button to be pressed 
while not button.pressed(button.LEFT):
    pass

# As long as the left button is being pressed, update the  variable 
while button.pressed(button.LEFT):
    left_button_press_duration = button.pressed(button.LEFT)

print("Left button was pressed for " + str(left_button_press_duration) + " milliseconds")

Parameters


button: int
A button from the button submodule in the hub module

Constants


hub.button Constants
LEFT = 1Left button next to the power button on the SPIKE Prime hubRIGHT = 2Right button next to the power button on the SPIKE Prime hub

Light
The light module includes functions to change the color of the lights on the SPIKE Prime hub.
To use the Light module add the following import statement to your project:

from hub import light
All functions in the module should be called inside the hub module as a prefix like so:

light.color(light.POWER, color.RED)

Functions

color
color(light: int, color: int) -> None
Change a the color of a light on the hub.

from hub import light
import color

# Change the light of the power button to red 
light.color(light.POWER, color.RED)

Parameters


light: int
The light on the hub

color: int
A color from the color module

Constants


hub.light Constants
POWER = 0The power button. On SPIKE Prime it's the button between the left and right buttons.CONNECT = 1The light around the Bluetooth connect button on SPIKE Prime.

Light Matrix
To use the Light Matrix module add the following import statement to your project:

from hub import light_matrix
All functions in the module should be called inside the hub module as a prefix like so:

light_matrix.write("Hello World")

Functions

clear
clear() -> None
Switches off all of the pixels on the Light Matrix.

from hub import light_matrix
import time
# Update pixels to show an image on Light Matrix, and then turn them off using the clear function 

# Show a small heart 
light_matrix.show_image(2)

# Wait for two seconds 
time.sleep_ms(2000)

# Switch off the heart 
light_matrix.clear()

Parameters


get_orientation
get_orientation() -> int
Retrieve the current orientation of the Light Matrix.

Parameters


get_pixel
get_pixel(x: int, y: int) -> int
Retrieve the intensity of a specific pixel on the Light Matrix.

from hub import light_matrix

# Show a heart 
light_matrix.show_image(1)

# Print the value of the center pixel's intensity 
print(light_matrix.get_pixel(2, 2))

Parameters


x: int
The X value

y: int
The Y value

invert
invert() -> None
Inverts all pixels on the Light Matrix. If a pixel is bright it becomes dark, and vice versa.

from hub import light_matrix
# Update pixels to invert an image on Light Matrix using the invert function 

# Show a small heart 
light_matrix.show_image(2)

# Invert the image, so the heart is unlit and the background is lit 
light_matrix.invert()

Parameters


set_orientation
set_orientation(top: int) -> int
Change the orientation of the Light Matrix. All subsequent calls will use the new orientation.

Parameters


top: int
The side of the hub to be the top

set_pixel
set_pixel(x: int, y: int, intensity: int) -> None
Sets the brightness of one pixel (one of the 25 LEDs) on the Light Matrix.

from hub import light_matrix
# Turn on the pixel in the center of the hub 
light_matrix.set_pixel(2, 2, 100)

Parameters


x: int
The X value

y: int
The Y value

intensity: int
How bright to light up the pixel

show
show(pixels: bytes) -> None
Change all the lights at the same time.

from hub import light_matrix
# Update all pixels on Light Matrix using the show function 

# Create a list with 25 identical intensity values 
pixels = [100] * 25 

# Wrap pixels list inside a bytes object 
pixels_bytes = bytes(pixels)

# Update all pixels to show same intensity 
light_matrix.show(pixels_bytes)

Parameters


pixels: Iterable
A bytes object containing light intensity values for all 25 pixels.

show_image
show_image(image: int, intensity: int = 100) -> None
Display one of the built in images on the display.

from hub import light_matrix
# Update pixels to show an image on Light Matrix using the show_image function 

# Show a smiling face 
light_matrix.show_image(3)

Parameters


image: int
The id of the image to show

intensity: int
How bright to light up the pixel

write
write(text: str, intensity: int = 100, time_per_character: int = 500) -> Awaitable
Displays text on the Light Matrix, one letter at a time, scrolling from right to left.

from hub import light_matrix
# White a message to the hub 
light_matrix.write("Hello, world!")

Parameters


text: str
The text to display

intensity: int
How bright to light up the pixel

time_per_character: int
How long to show each character on the display

Constants


hub.light_matrix Constants
BUSY0SUCCESS1ABORTED2

Motion Sensor
To use the Motion Sensor module add the following import statement to your project:

from hub import motion_sensor
All functions in the module should be called inside the hub module as a prefix like so:

motion_sensor.up_face()

Functions

acceleration
acceleration(raw_unfiltered: bool) -> tuple[int, int, int]
Returns a typle containing x, y & z acceleration values as integers.

Parameters


raw_unfiltered: bool
If we want the data back raw and unfiltered

angular_velocity
angular_velocity(raw_unfiltered: bool) -> tuple[int, int, int]
Returns a typle containing x, y & z angular velocity values as integers.

Parameters


raw_unfiltered: bool
If we want the data back raw and unfiltered

gesture
gesture() -> int
Returns the gesture recognized. Use a constant in motion_sensor module to easily compare it.

Parameters


get_yaw_face
get_yaw_face() -> int
Retrieve the hub yaw face.

Parameters


is_stable
is_stable() -> bool
Whether or not the hub is in resting flat.

Parameters


quaternion
quaternion() -> tuple[float, float, float, float]
Returns the quaternion as a tuple[w: float, x: float, y: float, z: float].

Parameters


reset_tap_count
reset_tap_count(count: int) -> bool
Reset the tap count returned by the tap_count function

Parameters


count: int
The new amount of taps to set

reset_tilt_angles
reset_tilt_angles() -> None
Reset the tilt angles.

Parameters


reset_yaw_angle
reset_yaw_angle(angle: int) -> None
Change the yaw angle offset.

Parameters


angle: int

set_tap_sensitivity
set_tap_sensitivity(threshold: int, configuration: int) -> bool

Parameters


threshold: int

configuration: int

set_yaw_face
set_yaw_face(up: int) -> bool
Change what hub face is used as the yaw face.

Parameters


up: int
The hub face that should be set as the upwards facing hub face. See available values inside the hub module.

tap_count
tap_count() -> int
Returns the gesture recognized. Use a constant in motion_sensor module to easily compare it.

Parameters


up_face
up_face() -> int
Returns the Hub face that is currently facing up

Parameters


Constants


hub.motion_sensor Constants
TAPPED = 0
DOUBLE_TAPPED = 1
SHAKEN = 2
FALLING = 3
UNKNOWN = -1

Port
This module contains constants that enables easy access to the ports on the SPIKE Prime hub. Use the contants in all functions that takes a port parameter.
To use the Button module add the following import statement to your project:

from hub import port
All functions in the module should be called inside the hub module as a prefix like so:

port.A

Constants


hub.port Constants
A = 0The Port that is labelled ‘A’ on the Hub.B = 1The Port that is labelled ‘B’ on the Hub.C = 2The Port that is labelled ‘C’ on the Hub.D = 3The Port that is labelled ‘D’ on the Hub.E = 4The Port that is labelled ‘E’ on the Hub.F = 5The Port that is labelled ‘F’ on the Hub.

Speaker
To use the Speaker module add the following import statement to your project:

from hub import speaker
All functions in the module should be called inside the hub module as a prefix like so:

speaker.stop()

Functions

beep
beep(frequency: int, duration: int, volume: int, *, attack: int = 0, decay: int = 0, sustain: int = 0, release: int = 0, transition: int = 0, waveform: int = 0, channel: int = 0) -> Awaitable
Plays a beep sound from the hub

Parameters


frequency: int
The frequency to play

duration: int
The duration in milliseconds

volume: int
The volume (0-100)



attack: int
The time taken for initial run-up of level from nil to peak, beginning when the key is pressed.

decay: int
The time taken for the subsequent run down from the attack level to the designated sustain level.

sustain: int
The level during the main sequence of the sound's duration, until the key is released.

release: int
The time taken for the level to decay from the sustain level to zero after the key is released

transition: int

waveform: int
The synthesized waveform. Use one of the constants in the hub.speaker module.

channel: int
The desired channel to play on (0-7)

stop
stop() -> None
Stops all noise from the hub

Parameters


volume
volume(volume: int) -> None

Parameters


volume: int
The volume (0-100)

Constants


hub.speaker Constants
ANY = -2
DEFAULT = -1
WAVEFORM_SINE = 1
WAVEFORM_SAWTOOTH = 3
WAVEFORM_SQUARE = 2
WAVEFORM_TRIANGLE = 1
CLICK = 0
STARTUP = 1
PROGRAM_START = 2
PROGRAM_STOP = 3
SHUTDOWN = 4

Functions

device_uuid
device_uuid() -> str
Retrieve the device id.

Parameters


hardware_id
hardware_id() -> str
Retrieve the hardware id.

Parameters


power_off
power_off() -> int
Turns off the hub.

Parameters


temperature
temperature() -> int
Retrieve the hub temperature.

Parameters


Constants


hub Constants
TOP = 0The SPIKE Prime hub face with the USB charging port.FRONT = 1The SPIKE Prime hub face with the Light Matrix.RIGHT = 2The right side of the SPIKE Prime hub when facing the front hub face.BOTTOM = 3The side of the SPIKE Prime hub where the battery is.BACK = 4The SPIKE Prime hub face where the speaker is.LEFT = 5The left side of the SPIKE Prime hub when facing the front hub face.

Motor
To use a Motor add the following import statement to your project:

import motor
All functions in the module should be called inside the motor module as a prefix like so:

motor.run(port.A, 1000)

Functions

absolute_position
absolute_position(port: int) -> int
Get the absolute position of a Motor

Parameters


port: int
A port from the port submodule in the hub module

get_duty_cycle
get_duty_cycle(port: int) -> int
Get the pwm of a Motor

Parameters


port: int
A port from the port submodule in the hub module

relative_position
relative_position(port: int) -> int
Get the relative position of a Motor

Parameters


port: int
A port from the port submodule in the hub module

reset_relative_position
reset_relative_position(port: int, position: int) -> None
Change the position used as the offset when using the run_to_relative_position function.

Parameters


port: int
A port from the port submodule in the hub module

position: int
The degree of the motor

run
run(port: int, velocity: int, *, acceleration: int = 1000) -> None
Start a Motor at a constant speed

from hub import port
import motor, time

# Start motor 
motor.run(port.A, 1000)

Parameters


port: int
A port from the port submodule in the hub module

velocity: int
The velocity in m/sec



acceleration: int
The acceleration (m/sec2)

run_for_degrees
run_for_degrees(port: int, degrees: int, velocity: int, *, stop: int = BRAKE, acceleration: int = 1000, deceleration: int = 1000) -> Awaitable
Turn a motor for a specific number of degrees

Parameters


port: int
A port from the port submodule in the hub module

degrees: int
The number of degrees

velocity: int
The velocity in m/sec



stop: int
The behavior of the Motor after it has stopped. Use the constants in the motor module.

acceleration: int
The acceleration (m/sec2)

deceleration: int
The deceleration (m/sec2)

run_for_time
run_for_time(port: int, duration: int, velocity: int, *, stop: int = BRAKE, acceleration: int = 1000, deceleration: int = 1000) -> Awaitable
Run a Motor for a limited amount of time

from hub import port
import runloop
import motor

async def main():
    # Run for 1 second 
    await motor.run_for_time(port.A, 1000, 280)

    # Run for 10 seconds with a slow deceleration 
    await motor.run_for_time(port.A, 10000, 280, deceleration=10)

runloop.run(main())

Parameters


port: int
A port from the port submodule in the hub module

duration: int
The duration in milliseconds

velocity: int
The velocity in m/sec



stop: int
The behavior of the Motor after it has stopped. Use the constants in the motor module.

acceleration: int
The acceleration (m/sec2)

deceleration: int
The deceleration (m/sec2)

run_to_absolute_position
run_to_absolute_position(port: int, position: int, velocity: int, *, direction: int, stop: int = BRAKE, acceleration: int = 1000, deceleration: int = 1000) -> Awaitable
Turn a motor to an absolute position.

Parameters


port: int
A port from the port submodule in the hub module

position: int
The degree of the motor

velocity: int
The velocity in m/sec



direction: int

stop: int
The behavior of the Motor after it has stopped. Use the constants in the motor module.

acceleration: int
The acceleration (m/sec2)

deceleration: int
The deceleration (m/sec2)

run_to_relative_position
run_to_relative_position(port: int, position: int, velocity: int, *, stop: int = BRAKE, acceleration: int = 1000, deceleration: int = 1000) -> Awaitable
Turn a motor to a position relative to the current position.

Parameters


port: int
A port from the port submodule in the hub module

position: int
The degree of the motor

velocity: int
The velocity in m/sec



stop: int
The behavior of the Motor after it has stopped. Use the constants in the motor module.

acceleration: int
The acceleration (m/sec2)

deceleration: int
The deceleration (m/sec2)

set_duty_cycle
set_duty_cycle(port: int, pwm: int) -> None
Start a Motor with a specific pwm

Parameters


port: int
A port from the port submodule in the hub module

pwm: int
The PWM value in percentage (0-100)

stop
stop(port: int, stop: int = BRAKE) -> None
Stops a motor

from hub import port
import motor, time

# Start motor 
motor.run(port.A, 1000)

# Wait for 2 seconds 
time.sleep_ms(2000)

# Stop motor 
motor.stop(port.A)

Parameters


port: int
A port from the port submodule in the hub module

stop: int
The behavior of the Motor after it has stopped. Use the constants in the motor module.

velocity
velocity(port: int) -> int
Get the velocity (m/sec) of a Motor

Parameters


port: int
A port from the port submodule in the hub module

Constants


motor Constants
READY = 1
RUNNING = 2
STALLED = -1
FAILED = -2
ERROR = -3
DISCONNECTED = 0
COAST = 1
BRAKE = 2
HOLD = 3
CONTINUE = 0
SMART_COAST = 4
SMART_BRAKE = 5
CLOCKWISE = 0
COUNTERCLOCKWISE = 1
SHORTEST_PATH = 2
LONGEST_PATH = 3

Motor Pair
The motor_pair module is used to run motors in a synchronized fashion. This mode is optimal for creating drivebases where you'd want a pair of motors to start and stop at the same time.
To use the motor_pair module simply import the module like so:

import motor_pair
motor_pair details

Functions

move
move(pair: int, steering: int, *, velocity: int = 360, acceleration: int = 1000) -> None
Move a Motor Pair at a constant speed until a new command is given.

from hub import port
import runloop
import motor_pair

async def main():
    # Unpair just in case 
    motor_pair.unpair(motor_pair.PAIR_1)

    # Pair motors on port A and B 
    motor_pair.pair(motor_pair.PAIR_1, port.A, port.B)

    await runloop.sleep_ms(2000)

    # Move straight at default velocity 
    motor_pair.move(motor_pair.PAIR_1, 0)

    await runloop.sleep_ms(2000)

    # Move straight at a specific velocity 
    motor_pair.move(motor_pair.PAIR_1, 0, velocity=280)

    await runloop.sleep_ms(2000)

    # Move straight at a specific velocity and acceleration 
    motor_pair.move(motor_pair.PAIR_1, 0, velocity=280, acceleration=100)runloop.run(main())

Parameters


pair: int
The pair slot of the Motor Pair.

steering: int
The steering (-100 to 100)



velocity: int
The velocity in m/sec

acceleration: int
The acceleration (m/sec2)

move_for_degrees
move_for_degrees(pair: int, degrees: int, steering: int, *, velocity: int = 360, stop: int = motor.BRAKE, acceleration: int = 1000, deceleration: int = 1000) -> Awaitable
Move a Motor Pair at a constant speed for a specific number of degrees.

from hub import port
import runloop
import motor_pair

async def main():
    # Unpair just in case 
    motor_pair.unpair(motor_pair.PAIR_1)

    # Pair motors on port A and B 
    motor_pair.pair(motor_pair.PAIR_1, port.A, port.B)

    # Move straight at default velocity for 90 degrees 
    await motor_pair.move_for_degrees(motor_pair.PAIR_1, 90, 0)

    # Move straight at a specific velocity for  second 
    await motor_pair.move_for_degrees(motor_pair.PAIR_1, 1000, 0, velocity=280)

    # Move straight at a specific velocity for 10 seconds with a slow deceleration 
    await motor_pair.move_for_degrees(motor_pair.PAIR_1, 10000, 0, velocity=280, deceleration=10)

runloop.run(main())

Parameters


pair: int
The pair slot of the Motor Pair.

degrees: int
The number of degrees

steering: int
The steering (-100 to 100)



velocity: int
The velocity in m/sec

stop: int
The behavior of the Motor after it has stopped. Use the constants in the motor module.

acceleration: int
The acceleration (m/sec2)

deceleration: int
The deceleration (m/sec2)

move_for_time
move_for_time(pair: int, duration: int, steering: int, *, velocity: int = 360, stop: int = motor.BRAKE, acceleration: int = 1000, deceleration: int = 1000) -> Awaitable
Move a Motor Pair at a constant speed for a specific duration.

from hub import port
import runloop
import motor_pair

async def main():
    # Unpair just in case 
    motor_pair.unpair(motor_pair.PAIR_1)

    # Pair motors on port A and B 
    motor_pair.pair(motor_pair.PAIR_1, port.A, port.B)

    # Move straight at default velocity for 1 second 
    await motor_pair.move_for_time(motor_pair.PAIR_1, 1000, 0)

    # Move straight at a specific velocity for 1 second 
    await motor_pair.move_for_time(motor_pair.PAIR_1, 1000, 0, velocity=280)

    # Move straight at a specific velocity for 10 seconds with a slow deceleration 
    await motor_pair.move_for_time(motor_pair.PAIR_1, 10000, 0, velocity=280, deceleration=10)

runloop.run(main())

Parameters


pair: int
The pair slot of the Motor Pair.

duration: int
The duration in milliseconds

steering: int
The steering (-100 to 100)



velocity: int
The velocity in m/sec

stop: int
The behavior of the Motor after it has stopped. Use the constants in the motor module.

acceleration: int
The acceleration (m/sec2)

deceleration: int
The deceleration (m/sec2)

move_tank
move_tank(pair: int, left_velocity: int, right_velocity: int, *, acceleration: int = 1000) -> None
Perform a tank move on a Motor Pair at a constant speed until a new command is given.

from hub import port
import runloop
import motor_pair

async def main():
    # Unpair just in case 
    motor_pair.unpair(motor_pair.PAIR_1)

    # Pair motors on port A and B 
    motor_pair.pair(motor_pair.PAIR_1, port.A, port.B)

    # Move straight at default velocity 
    motor_pair.move_tank(motor_pair.PAIR_1, 1000, 1000)

    await runloop.sleep_ms(2000)

    # Turn right 
    motor_pair.move_tank(motor_pair.PAIR_1, 0, 1000)

    await runloop.sleep_ms(2000)

    # Perform tank turn 
    motor_pair.move_tank(motor_pair.PAIR_1, 1000, -1000)

runloop.run(main())

Parameters


pair: int
The pair slot of the Motor Pair.

left_velocity: int
The velocity (m/sec) of the left motor.

right_velocity: int
The velocity (m/sec) of the right motor.



acceleration: int
The acceleration (m/sec2)

move_tank_for_degrees
move_tank_for_degrees(pair: int, degrees: int, left_velocity: int, right_velocity: int, *, stop: int = motor.BRAKE, acceleration: int = 1000, deceleration: int = 1000) -> Awaitable
Perform a tank move on a Motor Pair at a constant speed until a new command is given.

from hub import port
import runloop
import motor_pair

async def main():
    # Unpair just in case 
    motor_pair.unpair(motor_pair.PAIR_1)

    # Pair motors on port A and B 
    motor_pair.pair(motor_pair.PAIR_1, port.A, port.B)

    # Move straight at default velocity for 360 degrees 
    await motor_pair.move_tank_for_time(motor_pair.PAIR_1, 1000, 1000, 360)

    # Turn right for 180 degrees 
    await motor_pair.move_tank_for_time(motor_pair.PAIR_1, 0, 1000, 180)

    # Perform tank turn for 720 degrees 
    await motor_pair.move_tank_for_time(motor_pair.PAIR_1, 1000, -1000, 720)

runloop.run(main())

Parameters


pair: int
The pair slot of the Motor Pair.

degrees: int
The number of degrees

left_velocity: int
The velocity (m/sec) of the left motor.

right_velocity: int
The velocity (m/sec) of the right motor.



stop: int
The behavior of the Motor after it has stopped. Use the constants in the motor module.

acceleration: int
The acceleration (m/sec2)

deceleration: int
The deceleration (m/sec2)

move_tank_for_time
move_tank_for_time(pair: int, duration: int, left_velocity: int, right_velocity: int, *, stop: int = motor.BRAKE, acceleration: int = 1000, deceleration: int = 1000) -> Awaitable
Perform a tank move on a Motor Pair at a constant speed for a specific amount of time.

from hub import port
import runloop
import motor_pair

async def main():
    # Unpair just in case 
    motor_pair.unpair(motor_pair.PAIR_1)

    # Pair motors on port A and B 
    motor_pair.pair(motor_pair.PAIR_1, port.A, port.B)

    # Move straight at default velocity for 1 second 
    await motor_pair.move_tank_for_time(motor_pair.PAIR_1, 1000, 1000, 1000)

    # Turn right for 3 seconds 
    await motor_pair.move_tank_for_time(motor_pair.PAIR_1, 0, 1000, 3000)

    # Perform tank turn for 2 seconds 
    await motor_pair.move_tank_for_time(motor_pair.PAIR_1, 1000, -1000, 2000)

runloop.run(main())

Parameters


pair: int
The pair slot of the Motor Pair.

duration: int
The duration in milliseconds

left_velocity: int
The velocity (m/sec) of the left motor.

right_velocity: int
The velocity (m/sec) of the right motor.



stop: int
The behavior of the Motor after it has stopped. Use the constants in the motor module.

acceleration: int
The acceleration (m/sec2)

deceleration: int
The deceleration (m/sec2)

pair
pair(pair: int, left_motor: int, right_motor: int) -> None
pair two motors (left_motor & right_motor) and store the paired motors in pair.Use pair in all subsequent motor_pair related function calls.

import motor_pair

Parameters


pair: int
The pair slot of the Motor Pair.

left_motor: int
The port of the left motor. Use the port submodule in the hub module.

right_motor: int
The port of the right motor. Use the port submodule in the hub module.

stop
stop(pair: int, stop: int = motor.BRAKE) -> None
Stops a Motor Pair.

import motor_pair

motor_pair.stop(motor_pair.PAIR_1)

Parameters


pair: int
The pair slot of the Motor Pair.

stop: int
The behavior of the Motor after it has stopped. Use the constants in the motor module.

unpair
unpair(pair: int) -> None
Unpair a Motor Pair.

import motor_pair
from hub import port

motor_pair.unpair(motor_pair.PAIR_1)

Parameters


pair: int
The pair slot of the Motor Pair.

Constants


motor_pair Constants
COAST = 2The motor gradually stops due to friction.BRAKE = 1The motor stops due to friction, plus the voltage that is generated while the motor is still moving.HOLD = 3Stops the motor and actively holds it at its current angle.CONTINUE = 0The motor will not decelerate but instead continue into the next motor command.SMART_COAST = 7Make the motor coast when stopping.SMART_BRAKE = 8Make the motor coast when stopping.PAIR_1 = 0First Motor PairPAIR_2 = 1Second Motor PairPAIR_3 = 2Third Motor Pair

Rgb

Functions

color
color(light: int, color: int | tuple) -> None

Parameters


light: int
The light on the hub

color: int
A color from the color module

Constants


rgb Constants
POWER = 0
CONNECT = 1

Runloop
The runloop module contains all functions and constants to use the Force Sensor.
To use the Force Sensor module add the following import statement to your project:

import runloop
All functions in the module should be called inside the runloop module as a prefix like so:

runloop.run(some_async_function())

Functions

run
run(*functions: Awaitable) -> None
Start any number of parallel async functions. This is the function you should use to create programs with a similar structure to Word Blocks.

Parameters


*functions: awaitable
The functions to run

sleep_ms
sleep_ms(duration: int) -> Awaitable
Pause the execution of the application for any amount of milliseconds.

from hub import light_matrix
import runloop

async def main():
    light_matrix.write("Hi!")
    # Wait for ten seconds 
    await runloop.sleep_ms(10000)
    light_matrix.write("Are you still here?")

runloop.run(main())

Parameters


duration: int
The duration in milliseconds

To open SPIKE App 2 projects or use Python, go to spikelegacy.legoeducation.com.







This might take several minutes













Knowledge Base

API Modules


Color

Color Matrix

Color Sensor

Device

Distance Sensor

Force Sensor

Hub

Motor

Motor Pair

Rgb

Runloop
`},
        { "role": "user", "content": "What is my public IP address that I'm using right now?" }
      ];
      const functions = [
        {
          "name": "get_ip_address",
          "description": "Get the public IP address of the user",
          "parameters": {
            
          },
        }
      ];
      fetch("https://newchatcompletion-texhgputha-uc.a.run.app", {
        method: "POST",
        body: JSON.stringify({
          messages: messagesJSONList,
          functions: functions
        }),
        headers: {
          "Content-type": "application/json; charset=UTF-8"
        }
      })
        .then((res) => res.json()).then((res) => console.log(res))

    }
  </script>
</body>

</html>